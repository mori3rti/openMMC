<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>openMMC: modules/ipmb.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">openMMC
   
   </div>
   <div id="projectbrief">IPMControllerforAFCBoards</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('ipmb_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">modules/ipmb.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;FreeRTOS.h&quot;</code><br/>
<code>#include &quot;task.h&quot;</code><br/>
<code>#include &quot;queue.h&quot;</code><br/>
<code>#include &quot;semphr.h&quot;</code><br/>
<code>#include &quot;string.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="utils_8h_source.html">utils.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ipmb_8h_source.html">ipmb.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="ipmi_8h_source.html">ipmi.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="led_8h_source.html">led.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="port_8h_source.html">port.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="task__priorities_8h_source.html">task_priorities.h</a>&quot;</code><br/>
</div><div class="textblock"><div class="dynheader">
Include dependency graph for ipmb.c:</div>
<div class="dyncontent">
<div class="center"><img src="ipmb_8c__incl.png" border="0" usemap="#modules_2ipmb_8c" alt=""/></div>
<map name="modules_2ipmb_8c" id="modules_2ipmb_8c">
<area shape="rect" id="node13" href="utils_8h.html" title="General utilities functions." alt="" coords="353,83,409,112"/><area shape="rect" id="node15" href="ipmb_8h.html" title="Definitions used in IPMB Layer." alt="" coords="160,237,221,267"/><area shape="rect" id="node21" href="ipmi_8h.html" title="ipmi.h" alt="" coords="223,83,279,112"/><area shape="rect" id="node27" href="led_8h.html" title="led.h" alt="" coords="885,83,936,112"/><area shape="rect" id="node29" href="port_8h.html" title="Port layer (includes all portable functions headers)" alt="" coords="1001,160,1055,189"/><area shape="rect" id="node76" href="task__priorities_8h.html" title="task_priorities.h" alt="" coords="1760,83,1875,112"/><area shape="rect" id="node24" href="sdr_8h.html" title="sdr.h" alt="" coords="228,160,279,189"/><area shape="rect" id="node33" href="lpc17__gpio_8h.html" title="lpc17_gpio.h" alt="" coords="1099,237,1192,267"/><area shape="rect" id="node37" href="lpc17__i2c_8h.html" title="I2C driver for LPC17xx." alt="" coords="739,237,827,267"/><area shape="rect" id="node39" href="lpc17__ssp_8h.html" title="lpc17_ssp.h" alt="" coords="408,237,499,267"/><area shape="rect" id="node46" href="lpc17__spi_8h.html" title="Legacy SPI driver definitions for LPC17xx." alt="" coords="1597,237,1685,267"/><area shape="rect" id="node50" href="lpc17__watchdog_8h.html" title="Definitions of Watchdog driver implementation for LPC17xx." alt="" coords="1771,237,1896,267"/><area shape="rect" id="node54" href="lpc17__interruptions_8h.html" title="Interruptions control." alt="" coords="573,237,715,267"/><area shape="rect" id="node58" href="lpc17__hpm_8h.html" title="Firmware update functions (HPM.1)" alt="" coords="1216,237,1312,267"/><area shape="rect" id="node60" href="lpc17__power_8h.html" title="Definitions of power mode selection for LPC17xx." alt="" coords="851,237,957,267"/><area shape="rect" id="node64" href="lpc17__pincfg_8h.html" title="lpc17_pincfg.h" alt="" coords="1336,237,1443,267"/><area shape="rect" id="node69" href="lpc17__uart_8h.html" title="lpc17_uart.h" alt="" coords="981,237,1075,267"/></map>
</div>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a410dc1e7572425a449b5dc0f7ca9f69d">I2C_SPEED</a>&#160;&#160;&#160;100000</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#afb1fa450cf18fa7580c7a27c68f142a3">GPIO_GA_DELAY</a>&#160;&#160;&#160;10</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#ac17c490ff29305243b72c2f83c919cf5">ipmb_notify_client</a> (<a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a> *msg_cfg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Notifies the client that a new request has arrived and copies the message to its queue. This function receives a message wrapped in a <a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a> struct and copies only the <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> field to the client queue. Also, if a task has registered its handle in the caller_task field, notify it.  <a href="#ac17c490ff29305243b72c2f83c919cf5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a7732c86a719bbee62ce7383a583ea82c">ipmb_encode</a> (uint8_t *buffer, <a class="el" href="structipmi__msg.html">ipmi_msg</a> *msg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode IPMI msg struct to a byte formatted buffer.  <a href="#a7732c86a719bbee62ce7383a583ea82c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#ab1e2328f30108a9f68cac6e6cd233428">ipmb_decode</a> (<a class="el" href="structipmi__msg.html">ipmi_msg</a> *msg, uint8_t *buffer, uint8_t len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a buffer and copies to its specific fields in a <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> struct.  <a href="#ab1e2328f30108a9f68cac6e6cd233428"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a9da7268a374df3d8c20ec76bf5ae2a3a">IPMB_TXTask</a> (void *pvParameters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IPMB Transmitter Task.  <a href="#a9da7268a374df3d8c20ec76bf5ae2a3a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a5f3f27f298ef3643964b4085f905c031">IPMB_RXTask</a> (void *pvParameters)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">IPMB Receiver Task.  <a href="#a5f3f27f298ef3643964b4085f905c031"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a09d71f7adbd01a149b3778052c402b1d">ipmb_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the IPMB Layer.  <a href="#a09d71f7adbd01a149b3778052c402b1d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#ab33457f43ce9d42f9335c94568bcee90">ipmb_send_request</a> (<a class="el" href="structipmi__msg.html">ipmi_msg</a> *req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Format and send a request via IPMB channel.  <a href="#ab33457f43ce9d42f9335c94568bcee90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#ac0769acd22719fe34c97c1961c91ba26">ipmb_send_response</a> (<a class="el" href="structipmi__msg.html">ipmi_msg</a> *req, <a class="el" href="structipmi__msg.html">ipmi_msg</a> *resp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a027dc1f6ba3d5176fb46bade2c7afd88">ipmb_register_rxqueue</a> (QueueHandle_t *queue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a queue in which the client can block to receive the incoming requests.  <a href="#a027dc1f6ba3d5176fb46bade2c7afd88"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a2f65cfe781d852b8d1394830ad0ec739">ipmb_assert_chksum</a> (uint8_t *buffer, uint8_t buffer_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Asserts the input message checksums by comparing them with our calculated ones.  <a href="#a2f65cfe781d852b8d1394830ad0ec739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a1c987a2dc56422b57146391280f5e796">get_ipmb_addr</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads own I2C slave address using GA pins.  <a href="#a1c987a2dc56422b57146391280f5e796"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a194d3916e321c0f95416bb70055b23b3">ipmb_txqueue</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#af3472d74c30ad32c8d425acc85fce3f2">client_queue</a> = NULL</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ipmb_8c.html#a88a6ca39b5e01d455656304864acf459">IPMBL_TABLE</a> [<a class="el" href="ipmb_8h.html#a85cd4d157a04ad1efedfec4106a1fcac">IPMBL_TABLE_SIZE</a>]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Table holding all possible address values in IPMB specification.  <a href="#a88a6ca39b5e01d455656304864acf459"></a><br/></td></tr>
</table>
<hr/><h2>Define Documentation</h2>
<a class="anchor" id="afb1fa450cf18fa7580c7a27c68f142a3"></a><!-- doxytag: member="ipmb.c::GPIO_GA_DELAY" ref="afb1fa450cf18fa7580c7a27c68f142a3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="ipmb_8c.html#afb1fa450cf18fa7580c7a27c68f142a3">GPIO_GA_DELAY</a>&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The state of each GA signal is represented by G (grounded), U (unconnected), or P (pulled up to Management Power).</p>
<p>The MMC drives P1 low and reads the GA lines. The MMC then drives P1 high and reads the GA lines. Any line that changes state between the two reads indicate an unconnected (U) pin.</p>
<p>The IPMB-L address of a Module can be calculated as (70h + Site Number x 2). <br/>
 G = 0, P = 1, U = 2 <br/>
 | Pin | Ternary | Decimal | Address | |:---:|:-------:|:-------:|:-------:| | GGG | 000 | 0 | 0x70 | | GGP | 001 | 1 | 0x8A | | GGU | 002 | 2 | 0x72 | | GPG | 010 | 3 | 0x8E | | GPP | 011 | 4 | 0x92 | | GPU | 012 | 5 | 0x90 | | GUG | 020 | 6 | 0x74 | | GUP | 021 | 7 | 0x8C | | GUU | 022 | 8 | 0x76 | | PGG | 100 | 9 | 0x98 | | PGP | 101 | 10 | 0x9C | | PGU | 102 | 11 | 0x9A | | PPG | 110 | 12 | 0xA0 | | PPP | 111 | 13 | 0xA4 | | PPU | 112 | 14 | 0x88 | | PUG | 120 | 15 | 0x9E | | PUP | 121 | 16 | 0x86 | | PUU | 122 | 17 | 0x84 | | UGG | 200 | 18 | 0x78 | | UGP | 201 | 19 | 0x94 | | UGU | 202 | 20 | 0x7A | | UPG | 210 | 21 | 0x96 | | UPP | 211 | 22 | 0x82 | | UPU | 212 | 23 | 0x80 | | UUG | 220 | 24 | 0x7C | | UUP | 221 | 25 | 0x7E | | UUU | 222 | 26 | 0xA2 | </p>

</div>
</div>
<a class="anchor" id="a410dc1e7572425a449b5dc0f7ca9f69d"></a><!-- doxytag: member="ipmb.c::I2C_SPEED" ref="a410dc1e7572425a449b5dc0f7ca9f69d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define <a class="el" href="ipmb_8c.html#a410dc1e7572425a449b5dc0f7ca9f69d">I2C_SPEED</a>&#160;&#160;&#160;100000</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1c987a2dc56422b57146391280f5e796"></a><!-- doxytag: member="ipmb.c::get_ipmb_addr" ref="a1c987a2dc56422b57146391280f5e796" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="ipmb_8h.html#a1c987a2dc56422b57146391280f5e796">get_ipmb_addr</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads own I2C slave address using GA pins. </p>
<p>Based on coreipm/coreipm/mmc.c </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Gokhan Sozmen Reads the GA pins, performing an unconnection checking, to define the device I2C slave address, as specified by MicroTCA documentation.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>7-bit Slave Address</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Develop a function to discover the Geographic Address once (checking the GA pins) and store it into a global variable, since everytime a IPMI message is built (request or response) the MMC has to check its own address to fill the rs/rqSA field, and it takes some time to go through all this function. </dd></dl>

</div>
</div>
<a class="anchor" id="a2f65cfe781d852b8d1394830ad0ec739"></a><!-- doxytag: member="ipmb.c::ipmb_assert_chksum" ref="a2f65cfe781d852b8d1394830ad0ec739" args="(uint8_t *buffer, uint8_t buffer_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8h.html#a2f65cfe781d852b8d1394830ad0ec739">ipmb_assert_chksum</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buffer_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Asserts the input message checksums by comparing them with our calculated ones. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>Pointer to the message bytes. </td></tr>
    <tr><td class="paramname">buffer_len</td><td>Size of the message.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">ipmb_error_success</td><td>The message's checksum bytes are correct, therefore the message is valid. </td></tr>
    <tr><td class="paramname">ipmb_error_hdr_chksum</td><td>The header checksum byte is invalid. </td></tr>
    <tr><td class="paramname">ipmb_error_hdr_chksum</td><td>The final checksum byte is invalid. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1e2328f30108a9f68cac6e6cd233428"></a><!-- doxytag: member="ipmb.c::ipmb_decode" ref="ab1e2328f30108a9f68cac6e6cd233428" args="(ipmi_msg *msg, uint8_t *buffer, uint8_t len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8c.html#ab1e2328f30108a9f68cac6e6cd233428">ipmb_decode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipmi__msg.html">ipmi_msg</a> *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Decodes a buffer and copies to its specific fields in a <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> struct. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">msg</td><td>Pointer to a <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> struct which will hold the decoded message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>Pointer to a byte array that will be decoded </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of <code>buffer</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">ipmb_error_success</td><td>The message was successfully decoded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7732c86a719bbee62ce7383a583ea82c"></a><!-- doxytag: member="ipmb.c::ipmb_encode" ref="a7732c86a719bbee62ce7383a583ea82c" args="(uint8_t *buffer, ipmi_msg *msg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8c.html#a7732c86a719bbee62ce7383a583ea82c">ipmb_encode</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipmi__msg.html">ipmi_msg</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Encode IPMI msg struct to a byte formatted buffer. </p>
<p>This function formats the <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> struct fields into a byte array, following the specification:</p>
<p>| IPMB Messages | | | | | |----------------+---------+----------+---------+--------| | | REQUEST | RESPONSE | Bit Len | Byte # | |----------------+---------+----------+---------+--------| | Connection | rsSA | rqSA | 8 | 1 | | Header | NetFN | NetFN | 6 | 2 | | | rsLUN | rqLUN | 2 | 2 | |----------------+---------+----------+---------+--------| | Header Chksum | Chksum | Chksum | 8 | 3 | |----------------+---------+----------+---------+--------| | | rqSA | rsSA | 8 | 4 | | Callback Info | rqSeq | rqSeq | 6 | 5 | | | rqLUN | rsLUN | 2 | 5 | |----------------+---------+----------+---------+--------| | Command | CMD | CMD | 8 | 6 | |----------------+---------+----------+---------+--------| | Data | | CC | 8 | 7 | | | Data | Data | 8*N | 7+N | |----------------+---------+----------+---------+--------| | Message Chksum | Chksum | Checksum | 8 | 7+N+1 | |----------------+---------+----------+---------+--------|</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>Byte buffer which will hold the formatted message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">msg</td><td>The message struct to be formatted</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">ipmb_error_success</td><td>The message was successfully formatted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09d71f7adbd01a149b3778052c402b1d"></a><!-- doxytag: member="ipmb.c::ipmb_init" ref="a09d71f7adbd01a149b3778052c402b1d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="ipmb_8h.html#a09d71f7adbd01a149b3778052c402b1d">ipmb_init</a> </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the IPMB Layer. </p>
<p>Configures the I2C Driver, creates the TX queue for the IPMB Task and both IPMB RX and IPMB TX tasks </p>

</div>
</div>
<a class="anchor" id="ac17c490ff29305243b72c2f83c919cf5"></a><!-- doxytag: member="ipmb.c::ipmb_notify_client" ref="ac17c490ff29305243b72c2f83c919cf5" args="(ipmi_msg_cfg *msg_cfg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8c.html#ac17c490ff29305243b72c2f83c919cf5">ipmb_notify_client</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a> *&#160;</td>
          <td class="paramname"><em>msg_cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Notifies the client that a new request has arrived and copies the message to its queue. This function receives a message wrapped in a <a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a> struct and copies only the <a class="el" href="structipmi__msg.html" title="IPMI message struct.">ipmi_msg</a> field to the client queue. Also, if a task has registered its handle in the caller_task field, notify it. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">msg_cfg</td><td>The message that arrived, wrapped in the configuration struct <a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">ipmb_error_success</td><td>The message was successfully copied. </td></tr>
    <tr><td class="paramname">ipmb_error_timeout</td><td>The client_queue was full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a027dc1f6ba3d5176fb46bade2c7afd88"></a><!-- doxytag: member="ipmb.c::ipmb_register_rxqueue" ref="a027dc1f6ba3d5176fb46bade2c7afd88" args="(QueueHandle_t *queue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8h.html#a027dc1f6ba3d5176fb46bade2c7afd88">ipmb_register_rxqueue</a> </td>
          <td>(</td>
          <td class="paramtype">QueueHandle_t *&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates and returns a queue in which the client can block to receive the incoming requests. </p>
<p>The queue is created and its handler is written at the given pointer (queue). Also keeps a copy of the handler to know where to write the incoming messages.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>Pointer to a QueueHandle_t variable which will be written by this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt><b>Return values:</b></dt><dd>
  <table class="retval">
    <tr><td class="paramname">ipmb_error_success</td><td>The queue was successfully created. </td></tr>
    <tr><td class="paramname">ipmb_error_queue_creation</td><td>Queue creation failed due to lack of Heap space. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5f3f27f298ef3643964b4085f905c031"></a><!-- doxytag: member="ipmb.c::IPMB_RXTask" ref="a5f3f27f298ef3643964b4085f905c031" args="(void *pvParameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="ipmb_8h.html#a5f3f27f298ef3643964b4085f905c031">IPMB_RXTask</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IPMB Receiver Task. </p>
<p>Similarly to <a class="el" href="ipmb_8h.html#a9da7268a374df3d8c20ec76bf5ae2a3a" title="IPMB Transmitter Task.">IPMB_TXTask</a>, this task remains blocked until a new message is received by the I2C driver. The message passes through checksum checking to assure its integrity. <br/>
 If the message is a request, we have to check if it's a new one or just a retransmission of the last. In order to do this, the sequential number is tested, since every request has a different one.<br/>
 Right after that, the arrival time and the message body are stored for future checking and the specified client is notified using <a class="el" href="ipmb_8c.html#ac17c490ff29305243b72c2f83c919cf5" title="Notifies the client that a new request has arrived and copies the message to its queue. This function receives a message wrapped in a ipmi_msg_cfg struct and copies only the ipmi_msg field to the client queue. Also, if a task has registered its handle in the caller_task field, notify it.">ipmb_notify_client</a>.</p>
<p>If we have received a response instead, we match it with the last stored request and also check if the awating request hasn't timed-out yet.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>When a malformed message, a response without a request or a repeated request are received, they are just ignored, following the IPMB specifications.</dd></dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pvParameters,:</td><td>Default parameter to FreeRTOS tasks, not used here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ipmb_8h.html#a9da7268a374df3d8c20ec76bf5ae2a3a" title="IPMB Transmitter Task.">IPMB_TXTask</a> </dd>
<dd>
<a class="el" href="ipmb_8c.html#ac17c490ff29305243b72c2f83c919cf5" title="Notifies the client that a new request has arrived and copies the message to its queue. This function receives a message wrapped in a ipmi_msg_cfg struct and copies only the ipmi_msg field to the client queue. Also, if a task has registered its handle in the caller_task field, notify it.">ipmb_notify_client</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab33457f43ce9d42f9335c94568bcee90"></a><!-- doxytag: member="ipmb.c::ipmb_send_request" ref="ab33457f43ce9d42f9335c94568bcee90" args="(ipmi_msg *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8h.html#ab33457f43ce9d42f9335c94568bcee90">ipmb_send_request</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipmi__msg.html">ipmi_msg</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Format and send a request via IPMB channel. </p>

</div>
</div>
<a class="anchor" id="ac0769acd22719fe34c97c1961c91ba26"></a><!-- doxytag: member="ipmb.c::ipmb_send_response" ref="ac0769acd22719fe34c97c1961c91ba26" args="(ipmi_msg *req, ipmi_msg *resp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ipmb_8h.html#a8d757edf82d973e9e19ea700b3cd0671">ipmb_error</a> <a class="el" href="ipmb_8h.html#ac0769acd22719fe34c97c1961c91ba26">ipmb_send_response</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structipmi__msg.html">ipmi_msg</a> *&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structipmi__msg.html">ipmi_msg</a> *&#160;</td>
          <td class="paramname"><em>resp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9da7268a374df3d8c20ec76bf5ae2a3a"></a><!-- doxytag: member="ipmb.c::IPMB_TXTask" ref="a9da7268a374df3d8c20ec76bf5ae2a3a" args="(void *pvParameters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="ipmb_8h.html#a9da7268a374df3d8c20ec76bf5ae2a3a">IPMB_TXTask</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pvParameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>IPMB Transmitter Task. </p>
<p>When <a class="el" href="ipmb_8h.html#ab33457f43ce9d42f9335c94568bcee90" title="Format and send a request via IPMB channel.">ipmb_send_request</a> or <a class="el" href="ipmb_8h.html#ac0769acd22719fe34c97c1961c91ba26">ipmb_send_response</a> put a message in <a class="el" href="ipmb_8c.html#a194d3916e321c0f95416bb70055b23b3">ipmb_txqueue</a>, this task unblocks. First step to send a message is differentiating requests from responses. It does this analyzing the parity of NetFN (even for requests, odd for responses).</p>
<p>When sending a response, this task has to check if it matches with the sequence number from the last known request and the amount of time it took to be built (timeout checking). Last step is checking if it has already tried to send this message more than <a class="el" href="ipmb_8h.html#a5546e89aff8048ba1e566aaaed175c27" title="Maximum retries made by IPMB TX Task when sending a message.">IPMB_MAX_RETRIES</a> value. <br/>
 After passing all checking, the message is formatted as the IPMB protocol demands and passed down to the I2C driver, using the function xI2CWrite(). <br/>
 If an error comes out of the I2C driver when sending the message, it increases the retry counter in the <a class="el" href="structipmi__msg__cfg.html">ipmi_msg_cfg</a> struct and send the message to the front of <a class="el" href="ipmb_8c.html#a194d3916e321c0f95416bb70055b23b3">ipmb_txqueue</a>. <br/>
 If no errors occurs, the task that put the message in the queue is notified with a success flag.</p>
<p>The proccess is analog when sending a request, but the only check that is made is the retry number. The task skip all checking because, when sending a request, the message is formatted using it's own functions <a class="el" href="ipmb_8h.html#ab33457f43ce9d42f9335c94568bcee90" title="Format and send a request via IPMB channel.">ipmb_send_request</a> or <a class="el" href="ipmb_8h.html#ac0769acd22719fe34c97c1961c91ba26">ipmb_send_response</a> and they are guaranteed to put only valid messages in queue. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pvParameters,:</td><td>Default parameter to FreeRTOS tasks, not used here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ipmb_8h.html#a5f3f27f298ef3643964b4085f905c031" title="IPMB Receiver Task.">IPMB_RXTask</a> </dd>
<dd>
<a class="el" href="ipmb_8h.html#ab33457f43ce9d42f9335c94568bcee90" title="Format and send a request via IPMB channel.">ipmb_send_request</a> </dd>
<dd>
<a class="el" href="ipmb_8h.html#ac0769acd22719fe34c97c1961c91ba26">ipmb_send_response</a> </dd></dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af3472d74c30ad32c8d425acc85fce3f2"></a><!-- doxytag: member="ipmb.c::client_queue" ref="af3472d74c30ad32c8d425acc85fce3f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="ipmb_8c.html#af3472d74c30ad32c8d425acc85fce3f2">client_queue</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a194d3916e321c0f95416bb70055b23b3"></a><!-- doxytag: member="ipmb.c::ipmb_txqueue" ref="a194d3916e321c0f95416bb70055b23b3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QueueHandle_t <a class="el" href="ipmb_8c.html#a194d3916e321c0f95416bb70055b23b3">ipmb_txqueue</a> = NULL</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a88a6ca39b5e01d455656304864acf459"></a><!-- doxytag: member="ipmb.c::IPMBL_TABLE" ref="a88a6ca39b5e01d455656304864acf459" args="[IPMBL_TABLE_SIZE]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char <a class="el" href="ipmb_8c.html#a88a6ca39b5e01d455656304864acf459">IPMBL_TABLE</a>[<a class="el" href="ipmb_8h.html#a85cd4d157a04ad1efedfec4106a1fcac">IPMBL_TABLE_SIZE</a>]</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Initial value:</b><div class="fragment"><pre class="fragment"> {
    0x70, 0x8A, 0x72, 0x8E, 0x92, 0x90, 0x74, 0x8C, 0x76,
    0x98, 0x9C, 0x9A, 0xA0, 0xA4, 0x88, 0x9E, 0x86, 0x84,
    0x78, 0x94, 0x7A, 0x96, 0x82, 0x80, 0x7C, 0x7E, 0xA2 }
</pre></div>
<p>Table holding all possible address values in IPMB specification. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="ipmb_8c.html#a1c987a2dc56422b57146391280f5e796" title="Reads own I2C slave address using GA pins.">get_ipmb_addr()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="ipmb_8c.html">ipmb.c</a>      </li>

    <li class="footer">Generated on Mon Jun 27 2016 19:01:01 for openMMC by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
